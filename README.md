# Study-C++
there are some notes about C++ .
# 每天进步一点点
 1.  Effective C++

  二、构造、析构和赋值运算
构造和析构一方面是对象的诞生和终结；另一方面，它们也意味着资源的开辟和归还。这些操作犯错误会导致深远的后果——你需要产生和销毁的每一个对象都面临着风险。这些函数形成了一个自定义类的脊柱，所以如何确保这些函数的行为正确是“生死攸关”的大事。

    条款05：了解C++默默编写并调用了哪些函数
编译器会主动为你编写的任何类声明一个拷贝构造函数、拷贝复制操作符和一个析构函数，同时如果你没有生命任何构造函数，编译器也会为你声明一个default版本的拷贝构造函数，这些函数都是public且inline的。注意，上边说的是声明哦，只有当这些函数有调用需求的时候，编译器才会帮你去实现它们。但是编译器替你实现的函数可能在类内引用、类内指针、有const成员以及类型有虚属性的情形下会出问题。

   对于拷贝构造函数，你要考虑到类内成员有没有深拷贝的需求，如果有的话就需要自己编写拷贝构造函数/操作符，而不是把这件事情交给编译器来做。
对于拷贝构造函数，如果类内有引用成员或const成员，你需要自己定义拷贝行为，因为编译器替你实现的拷贝行为在上述两个场景很有可能是有问题的。
对于析构函数，如果该类有多态需求，请主动将析构函数声明为virtual，具体请看条款07 。
除了这些特殊的场景以外，如果不是及其简单的类型，请自己编写好构造、析构、拷贝构造和赋值操作符、移动构造和赋值操作符（C++11、如有必要）这六个函数。

    条款06：若不想使用编译器自动生成的函数，就该明确拒绝。
承接上一条款，如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么你就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：

将被禁止生成的函数声明为private并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。
将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。
但是有了C++11，我们可以直接使用= delete来声明拷贝构造函数，显示禁止编译器生成该函数。

    条款07：为多态基类声明virtual
该条款的核心内容为：带有多态性质的基类必须将析构函数声明为虚函数，防止指向子类的基类指针在被释放时只局部销毁了该对象。如果一个类有多态的内涵，那么几乎不可避免的会有基类的指针（或引用）指向子类对象，因为非虚函数没有动态类型，所以如果基类的析构函数不是虚函数，那么在基类指针析构时会直接调用基类的析构函数，造成子类对象仅仅析构了基类的那一部分，有内存泄漏的风险。除此之外，还需注意：

   需要注意的是，普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价，详情《More Effective C++》条款24。

   如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为final（C++ 11），这样禁止派生可以防止误继承造成上述问题。
编译器自动生成的析构函数时非虚的，所以多态基类必须将析构函数显示声明为virtual。                                                                                                    
     条款08：别让异常逃离析构函数
析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。

   一个直观的解释：析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明抛出异常后的代码无法再继续执行，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃，这是每一个程序员都不想看到的。

  话说回来，如果某些操作真的很容易抛出异常，如资源的归还等，并且你又不想把异常吞掉，那么就请把这些操作移到析构函数之外，提供一个普通函数做类似的清理工作，在析构函数中只负责记录，我们需要时刻保证析构函数能够执行到底。

    条款09：绝不在构造和析构过程中调用virtual函数。
结论正如该条款的名字：请不要在构造函数和析构函数中调用virtual函数。

在多态环境中，我们需要重新理解构造函数和析构函数的意义，这两个函数在执行过程中，涉及到了对象类型从基类到子类，再从子类到基类的转变。

   一个子类对象开始创建时，首先调用的是基类的构造函数，在调用子类构造函数之前，该对象将一直保持着“基类对象”的身份而存在，自然在基类的构造函数中调用的虚函数——将会是基类的虚函数版本，在子类的构造函数中，原先的基类对象变成了子类对象，这时子类构造函数里调用的是子类的虚函数版本。这是一件有意思的事情，这说明在构造函数中虚函数并不是虚函数，在不同的构造函数中，调用的虚函数版本并不同，因为随着不同层级的构造函数调用时，对象的类型在实时变化。那么相似的，析构函数在调用的过程中，子类对象的类型从子类退化到基类。

   因此，如果你指望在基类的构造函数中调用子类的虚函数，那就趁早打消这个想法好了。但很遗憾的是，你可能并没有意识到自己做出了这样的设计，例如将构造函数的主要工作抽象成一个init()函数以防止不同构造函数的代码重复是一个很常见的做法，但是在init()函数中是否调用了虚函数，就要好好注意一下了，同样的情况在析构函数中也是一样。
 
    条款10：令operator =返回一个reference to *this
简单来说：这样做可以让你的赋值操作符实现“连等”的效果：

x = y = z = 10;
在设计接口时一个重要的原则是，让自己的接口和内置类型相同功能的接口尽可能相似，所以如果没有特殊情况，就请让你的赋值操作符的返回类型为ObjectClass&类型并在代码中返回*this吧。

    条款11：在operator=中处理“自我赋值”
自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要假借指针来实现：

     *pa = *pb;		 			//pa和pb指向同一对象，便是自我赋值。
     arr[i] = arr[j];		//i和j相等，便是自我赋值
那么对于管理一定资源的对象重载的operator = 中，一定要对是不是自我赋值格外小心并且增加预判，因为无论是深拷贝还是资源所有权的转移，原先的内存或所有权一定会被清空才能被赋值，如果不加处理，这套逻辑被用在自我赋值上会发生——先把自己的资源给释放掉了，然后又把以释放掉的资源赋给了自己——出错了。

第一种做法是在赋值前增加预判，但是这种做法没有异常安全性，试想如果在删除掉原指针指向的内存后，在赋值之前任何一处跑出了异常，那么原指针就指向了一块已经被删除的内存。

        SomeClass& SomeClass::operator=(const SomeClass& rhs) 
       {
         if (this == &rhs) return *this;
  
         delete ptr;	
         ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr将指向一块已经被删除的内存。
         return *this;
       }
如果我们把异常安全性也考虑在内，那么我们就会得到如下方法，令人欣慰的是这个方法也解决了自我赋值的问题。

       SomeClass& SomeClass::operator=(const SomeClass& rhs) 
       {
         DataBlock* pOrg = ptr;
         ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr仍然指向之前的内存。
         delete pOrg;
         return *this;
       }
另一个使用copy and swap技术的替代方案将在条款29中作出详细解释。

    条款12：复制对象时勿忘其每一个成分
所谓“每一个成分”，作者在这里其实想要提醒大家两点：

当你给类多加了成员变量时，请不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果你忘记处理，编译器也不会报错。

如果你的类有继承，那么在你为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是private的，所以你无法访问它们，你应该让子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数：

     //在成员初始化列表显示调用基类的拷贝构造函数
       ChildClass::ChildClass(const ChildClass& rhs) : BaseClass(rhs) 
        {		
  	// ...
        }
除此之外，拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个，这虽然看上去是一个避免代码重复好方法，但是是荒谬的。其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。不要这么做！


